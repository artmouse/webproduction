<h1>Как правильно писать блоки к интерфейсу интернет-магазина? (shop blocks)</h1>

<h2>Что такое блоки (shop blocks)?</h2>
Откройте любой интернет-магазин, например yazz.com.ua.<br />
Все что вы увидите на странице - это визуальные блоки, они же shopblocks (shopblock).<br />
С технической точки зрения блоки - это такие же контенты (contents) как и любая страница, только у них нет URL.<br />
<strong>Внимание! Блоки работают ТОЛЬКО для морды интернет-магазина</strong>, в админке их нет.<br />
<br />

<h2>Зачем нужны блоки?</h2>
<ul>
    <li>Пользователю блоки нужны для того, чтобы пользователь мог управлять интерфейсом своего магазина: включать и отключать нужные блоки.</li>
    <li>Разработчикам нужны блоки для того, чтобы иметь возможность добавлять функционал на страницы без изменения кода движка, без копипаста всего шаблона ради того, чтобы изменить одну кнопку или добавить один блок.</li>
    <li>Так же блоки можно кешировать, чтобы не заставлять систему каждый раз обрабатывать их заново. О кешировании ниже.</li>
</ul>
<br />
<br />

<h2>Как добавить свой блок из модуля?</h2>
Чтобы добавить свой блок, вам нужно:<br />
<br />

1. Объявить контент блока в вашем модуле<br />
<code><pre>
Engine::GetContentDataSource()->registerContent(
    'block-myblock1', array(
        'filehtml' => dirname(__FILE__).'/contents/block_myblock1.html',
        'filephp' => dirname(__FILE__).'/contents/block_myblock1.php',
    ), 'override'
);
</pre></code>
<br />
<br />

<span style="color:red;">
<strong>Внимание!</strong> Идентификатор блока (contentID) всегда должен начинаться на "block-".
Не "block_", не "-block", а именно "block-". Иначе ничего работать не будет и у вас будет вечные циклы рекурсии!
</span>

<br />
<br />

2. Зарегистрировать блок в системе блоков.<br />
Обязательно регистрируйте блок в в режиме build.<br />
<br />

3. Один раз запустить движок в режиме build или запустить updater.sh<br />
Это зарегистрирует блок физически.<br />
<br />

<code><pre>
if (PackageLoader::Get()->getMode('build')) {
    // Shop::Get()->getBlockService()->addBlock($name, $contentID);
    // В нашем случае:
    Shop::Get()->getBlockService()->addBlock('Мой тестовый блок', 'block-myblock1');
}
</pre></code>
<br />
<br />

4. Открыть шаблон или любой HTML-файл.<br />
Где угодно прописать smarty-переменную $block_myblock1 (дефисы заменяются на знак подчеркивания автоматически, поэтому block-myblock1 превращается в block_myblock1).<br />
<br />

<h2>Как управлять списком блоков?</h2>
Пользовать и администратор может управлять списком блоков из <a href="/admin/shop/block/">админки</a>.<br />
Тут можно отключить какой-то блок (скрыть его) или изменить его параметры (доступно для некоторых блоков)<br />
<br />

<h2>Как можно подставлять блоки в шаблон?</h2>
Есть два способа:<br />
<ol>
    <li>Открыть шаблон и просто прописать переменную. Мы используем такой способ для custom-дизайнов интернет-магазинов. То есть, если уже вся верстка custom-ная, то чего заморачиваться - в нее и по подставляем блоки.</li>
    <li>Используя специальные точки подключения. Например, у нас есть стандартный магазин yazz. На главную страницу нужно добавить блок, но ради этого копировать весь шаблон (или даже часть шаблона) и подставить туда одну переменную - кажется говнокодом, Поэтому есть специальные точки подключения, это заранее заготовленные переменные в шаблонах, в которые можно подставить много блоков.</li>
</ol>
<br />
<br />

<h2>Как работают точки подключения блоков (positions)?</h2>
Когда вы подключаете блок, вы можете задать дополнительные параметры<br />

<code><pre>
Shop::Get()->getBlockService()->addBlock($name, $contentID, $position, $positionSort);
</pre></code>
<br />
<br />

Где $positon - это название точки подключения.<br />
А $positionSort - это каким по порядку этот блок будет для точки подключения, если блоков будет несколько.<br />
<br />

<h2>Список доступных точек подключения:</h2>
В шаблоне shop_tpl.html<br />
<ul>
    <li>block_position_global_top - в начале шаблона</li>
    <li>block_position_global_bottom - в конце шаблона</li>
</ul>
<br />
<br />

В шаблоне shop_tpl_column.html<br />
<ul>
    <li>block_position_template_top - в начале шаблона</li>
    <li>block_position_template_bottom - в конце шаблона</li>
    <li>block_position_template_column_top - в колонке сверху</li>
    <li>block_position_template_column_middle - в колонке в середине</li>
    <li>block_position_template_column_bottom - в колонке внизу</li>
</ul>
<br />
<br />

Но, у вас так же есть возможность поставиться над/под каким-либо существующим блоком.<br />
Например, хотите прицепиться после логотипа? Регистрируем свой блок так:
<br />
<br />

<code><pre>
Shop::Get()->getBlockService()->addBlock('Мой тестовый блок', 'block-myblock1', 'block-logo', +1);
// или перед логотипом
Shop::Get()->getBlockService()->addBlock('Мой тестовый блок', 'block-myblock1', 'block-logo', -1);
</pre></code>
<br />
<br />

То есть, в качестве точки подключения используем точку уже существующего блока.<br />
<br />

<h2>Как заменить существующий блок?</h2>
Если вам нужно заменить логику работы существующего блока, то просто переопределяйте
его контент заново по правилам переопределения контентов (см инструкцию).<br />
<br />

<code><pre>
Engine::GetContentDataSource()->registerContent(
    'block-logo', array(
        'filehtml' => dirname(__FILE__).'/contents/block_mylogo.html',
        'filephp' => dirname(__FILE__).'/contents/block_mylogo.php',
    ), 'override'
);
</pre></code>
<br />
<br />

Если вы хотите изменить название блока или его позицию, точку подключения программно, то в режиме build просто вызовите регистрацию блока еще раз с нужными вам параметрами:
<br />

<code><pre>
if (PackageLoader::Get()->getMode('build')) {
    Shop::Get()->getBlockService()->addBlock('Я переименовал блок логотипа', 'block-logo');
}
</pre></code>

<h2>Реальные примеры</h2>
Больше реальных примеров вы найдете в файлах:<br />
/api/include.php (см комментарий регистрация block-ов в таблице блоков)<br />
Все стандартные блоки зарегистрированы в /contents/contents_global.php, все блоки начинаются на block-.<br />
<br />

<h2>Где и как технически работают блоки?</h2>
Технически все блоки записываются в таблицу shopblock, а затем внутрь каждого контента они подставляются из Shop_BlockService, который висит на событии beforeContentProcess в Engine.
<br />

<h2>Как кешировать блоки?</h2>
Блоки можно закешировать, это добавляет производительности всей системе в целом, так как не нужно больше обрабатывать каждый блок. Например, тот же блок логотипа - он практически никогда не меняется.
<br />
<br />

Блоки кешируются как обычные контенты.<br />
Для этого в контенте блока допишите параметр cache.<br />
<br />

<code><pre>
Engine::GetContentDataSource()->registerContent(
    'block-myblock1', array(
        'filehtml' => dirname(__FILE__).'/contents/block_myblock.html',
        'filephp' => dirname(__FILE__).'/contents/block_myblock.php',
        'cache' => array('ttl' => 3600, 'type' => 'content', 'modifiers' => array('language', 'host')),
    ), 'override'
);
</pre></code>
<br />
<br />

В приведенном примере блок будет закеширован полностью на 3600 секунд, под каждый host и язык проекта будет кешироваться своя версия блока.<br />
Больше примеров можно посмотреть в /contents/contents_global.php.<br />
<br />